{"version":3,"sources":["ng://@angular-redux/router/actions.ts","ng://@angular-redux/router/router.ts","ng://@angular-redux/router/index.ts","ng://@angular-redux/router/reducer.ts"],"names":["UPDATE_LOCATION","NgReduxRouter","router","ngRedux","applicationRef","location","this","state","prototype","destroy","urlStateSubscription","unsubscribe","reduxSubscription","initialized","initialize","selectLocationFromState","urlState$","Error","urlState","getDefaultUrlStateObservable","listenToRouterChanges","listenToReduxChanges","events","pipe","filter","event","NavigationEnd","map","_this","path","distinctUntilChanged","getLocationFromStore","useInitial","getState","initialLocation","subscribe","currentLocation","undefined","dispatch","type","payload","select","locationInStore","navigateByUrl","Injectable","Router","NgRedux","ApplicationRef","Location","NgReduxRouterModule","forRoot","ngModule","providers","NgModule","routerReducer","action"],"mappings":"qjBAAA,IAAaA,EAA0B,yCCAvC,IAAAC,EAAA,WAwBE,SAAAA,EACUC,EACAC,EACAC,EACAC,GAHAC,KAAAJ,OAAAA,EACAI,KAAAH,QAAAA,EACAG,KAAAF,eAAAA,EACAE,KAAAD,SAAAA,oBAZY,+BAkEoC,SAAAE,GACxD,OAAAA,EAAML,eA9CRD,EAAAO,UAAAC,QAAA,WACMH,KAAKI,sBACPJ,KAAKI,qBAAqBC,cAGxBL,KAAKM,mBACPN,KAAKM,kBAAkBD,cAGzBL,KAAKO,aAAc,GAiBrBZ,EAAAO,UAAAM,WAAA,SACEC,EACAC,GAEA,QAHA,IAAAD,IAAAA,EAAA,SAAkDR,GAAS,OAAAA,EAAML,SAG7DI,KAAKO,YACP,MAAM,IAAII,MACR,iGAIJX,KAAKS,wBAA0BA,EAE/BT,KAAKY,SAAWF,GAAaV,KAAKa,+BAElCb,KAAKc,wBACLd,KAAKe,uBACLf,KAAKO,aAAc,GAMbZ,EAAAO,UAAAW,mDACN,OAAOb,KAAKJ,OAAOoB,OAAOC,KACxBC,EAAAA,OAAO,SAAAC,GAAS,OAAAA,aAAiBC,EAAAA,gBACjCC,EAAAA,IAAI,SAAAF,GAAS,OAAAG,EAAKvB,SAASwB,SAC3BC,EAAAA,yBAII7B,EAAAO,UAAAuB,8BAAqBC,GAC3B,YAD2B,IAAAA,IAAAA,GAAA,GAEzB1B,KAAKS,wBAAwBT,KAAKH,QAAQ8B,cACzCD,EAAa1B,KAAK4B,gBAAkB,KAIjCjC,EAAAO,UAAAY,4CA0BFd,KAAKY,WACPZ,KAAKI,qBAAuBJ,KAAKY,SAASiB,UA1Bf,SAAC9B,GAC5B,GAAIuB,EAAKQ,kBAAoB/B,EAA7B,CAMA,GADAuB,EAAKQ,gBAAkB/B,EACnBuB,EAAKM,kBAAoBG,YAC3BT,EAAKM,gBAAkB7B,EAKGuB,EAAKG,yBACLH,EAAKQ,iBAC7B,OAIJR,EAAKzB,QAAQmC,SAAS,CACpBC,KAAMvC,EACNwC,QAASnC,SASPJ,EAAAO,UAAAa,2CAiBNf,KAAKM,kBAAoBN,KAAKH,QAC3BsC,OAAO,SAAAlC,GAAS,OAAAqB,EAAKb,wBAAwBR,KAC7CgB,KAAKO,EAAAA,wBACLK,UAnB0B,SAAC9B,GAC5B,GAAIuB,EAAKM,kBAAoBG,UAA7B,CAKA,IAAMK,EAAkBd,EAAKG,sBAAqB,GAC9CH,EAAKQ,kBAAoBM,IAK7Bd,EAAKQ,gBAAkB/B,EACvBuB,EAAK1B,OAAOyC,cAActC,4BAnI/BuC,EAAAA,sDAPCC,EAAAA,cAPOC,EAAAA,eAEAC,EAAAA,sBADAC,EAAAA,cADT,GCAAC,EAAA,gCAOSA,EAAAC,QAAP,WACE,MAAO,CACLC,SAAUF,EACVG,UAAW,CAACnD,yBALjBoD,EAAAA,aALD,6DCUA,SAAAC,EACE/C,EACAgD,GAEA,YAHA,IAAAhD,IAAAA,EAPwC,IAUhCgD,EAAOhB,MACb,KAAKvC,EACH,OAAOuD,EAAOf,SAZsB,GAatC,QACE,OAAOjC","sourcesContent":["export const UPDATE_LOCATION: string = '@angular-redux/router::UPDATE_LOCATION';\n","import { NgRedux } from '@angular-redux/store';\nimport { Location } from '@angular/common';\nimport { ApplicationRef, Injectable } from '@angular/core';\nimport {\n  DefaultUrlSerializer,\n  NavigationCancel,\n  NavigationEnd,\n  Router,\n} from '@angular/router';\nimport { Observable, Subscription } from 'rxjs';\nimport { distinctUntilChanged, filter, map } from 'rxjs/operators';\nimport { UPDATE_LOCATION } from './actions';\nimport { DefaultRouterState, RouterAction } from './reducer';\n\n@Injectable()\nexport class NgReduxRouter {\n  private initialized = false;\n  private currentLocation?: string;\n  private initialLocation?: string;\n  private urlState?: Observable<string>;\n\n  private urlStateSubscription?: Subscription;\n  private reduxSubscription?: Subscription;\n\n  constructor(\n    private router: Router,\n    private ngRedux: NgRedux<any>,\n    private applicationRef: ApplicationRef,\n    private location: Location,\n  ) {}\n\n  /**\n   * Destroys the bindings between @angular-redux/router and @angular/router.\n   * This method unsubscribes from both @angular-redux/router and @angular router, in case\n   * your app needs to tear down the bindings without destroying Angular or Redux\n   * at the same time.\n   */\n  destroy() {\n    if (this.urlStateSubscription) {\n      this.urlStateSubscription.unsubscribe();\n    }\n\n    if (this.reduxSubscription) {\n      this.reduxSubscription.unsubscribe();\n    }\n\n    this.initialized = false;\n  }\n\n  /**\n   * Initialize the bindings between @angular-redux/router and @angular/router\n   *\n   * This should only be called once for the lifetime of your app, for\n   * example in the constructor of your root component.\n   *\n   *\n   * @param selectLocationFromState Optional: If your\n   * router state is in a custom location, supply this argument to tell the\n   * bindings where to find the router location in the state.\n   * @param urlState$ Optional: If you have a custom setup\n   * when listening to router changes, or use a different router than @angular/router\n   * you can supply this argument as an Observable of the current url state.\n   */\n  initialize(\n    selectLocationFromState: (state: any) => string = state => state.router,\n    urlState$?: Observable<string> | undefined,\n  ) {\n    if (this.initialized) {\n      throw new Error(\n        '@angular-redux/router already initialized! If you meant to re-initialize, call destroy first.',\n      );\n    }\n\n    this.selectLocationFromState = selectLocationFromState;\n\n    this.urlState = urlState$ || this.getDefaultUrlStateObservable();\n\n    this.listenToRouterChanges();\n    this.listenToReduxChanges();\n    this.initialized = true;\n  }\n\n  private selectLocationFromState: (state: any) => string = state =>\n    state.router;\n\n  private getDefaultUrlStateObservable() {\n    return this.router.events.pipe(\n      filter(event => event instanceof NavigationEnd),\n      map(event => this.location.path()),\n      distinctUntilChanged(),\n    );\n  }\n\n  private getLocationFromStore(useInitial: boolean = false) {\n    return (\n      this.selectLocationFromState(this.ngRedux.getState()) ||\n      (useInitial ? this.initialLocation : '')\n    );\n  }\n\n  private listenToRouterChanges() {\n    const handleLocationChange = (location: string) => {\n      if (this.currentLocation === location) {\n        // Dont dispatch changes if we haven't changed location.\n        return;\n      }\n\n      this.currentLocation = location;\n      if (this.initialLocation === undefined) {\n        this.initialLocation = location;\n\n        // Fetch initial location from store and make sure\n        // we dont dispath an event if the current url equals\n        // the initial url.\n        const locationFromStore = this.getLocationFromStore();\n        if (locationFromStore === this.currentLocation) {\n          return;\n        }\n      }\n\n      this.ngRedux.dispatch({\n        type: UPDATE_LOCATION,\n        payload: location,\n      });\n    };\n\n    if (this.urlState) {\n      this.urlStateSubscription = this.urlState.subscribe(handleLocationChange);\n    }\n  }\n\n  private listenToReduxChanges() {\n    const handleLocationChange = (location: string) => {\n      if (this.initialLocation === undefined) {\n        // Wait for router to set initial location.\n        return;\n      }\n\n      const locationInStore = this.getLocationFromStore(true);\n      if (this.currentLocation === locationInStore) {\n        // Dont change router location if its equal to the one in the store.\n        return;\n      }\n\n      this.currentLocation = location;\n      this.router.navigateByUrl(location);\n    };\n\n    this.reduxSubscription = this.ngRedux\n      .select(state => this.selectLocationFromState(state))\n      .pipe(distinctUntilChanged())\n      .subscribe(handleLocationChange);\n  }\n}\n","import { ModuleWithProviders, NgModule } from '@angular/core';\nimport { UPDATE_LOCATION } from './actions';\nimport { RouterAction, routerReducer } from './reducer';\nimport { NgReduxRouter } from './router';\n\n@NgModule()\nexport class NgReduxRouterModule {\n  static forRoot(): ModuleWithProviders {\n    return {\n      ngModule: NgReduxRouterModule,\n      providers: [NgReduxRouter],\n    };\n  }\n}\n\nexport { NgReduxRouter, RouterAction, routerReducer, UPDATE_LOCATION };\n","import { Action } from 'redux';\n\nimport { UPDATE_LOCATION } from './actions';\n\nexport const DefaultRouterState: string = '';\n\nexport interface RouterAction extends Action {\n  payload?: string;\n}\n\nexport function routerReducer(\n  state: string = DefaultRouterState,\n  action: RouterAction,\n): string {\n  switch (action.type) {\n    case UPDATE_LOCATION:\n      return action.payload || DefaultRouterState;\n    default:\n      return state;\n  }\n}\n"]}