{"version":3,"sources":["ng://@angular-redux/form/compose-reducers.ts","ng://@angular-redux/form/form-store.ts","null","ng://@angular-redux/form/form-exception.ts","ng://@angular-redux/form/state.ts","ng://@angular-redux/form/configure.ts","ng://@angular-redux/form/connect/connect-base.ts","ng://@angular-redux/form/connect/connect-reactive.ts","ng://@angular-redux/form/connect/connect.ts","ng://@angular-redux/form/connect/connect.module.ts","ng://@angular-redux/form/connect-array/connect-array-template.ts","ng://@angular-redux/form/connect-array/connect-array.ts","ng://@angular-redux/form/shims.ts","ng://@angular-redux/form/connect-array/connect-array.module.ts","ng://@angular-redux/form/module.ts","ng://@angular-redux/form/form-reducer.ts"],"names":["FORM_CHANGED","FormStore","store","this","prototype","getState","subscribe","fn","_this","valueChanged","path","form","value","dispatch","type","payload","valid","Injectable","NgRedux","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__extends","__","constructor","create","__assign","assign","t","s","i","n","arguments","length","call","apply","__values","o","m","Symbol","iterator","next","done","__read","r","e","ar","push","error","__spread","concat","FormException","_super","msg","tslib_1.__extends","Error","State","traverse","state","deepValue","path_1","tslib_1.__values","path_1_1","k","parent_1","Iterable","isIterable","get","Map","transformed","slice","indexOf","undefined","operations","inspect","update","root","clone","parent","key","remainingPath","innerValue","parentOperations","innerOperations","merge","stateKey","isArray","ImmutableMap","object","metaOperations","cloned","v","set","mergeDeepIn","isMap","mergeDeep","splice","_","setter","clear","forEach","mapValue","index","WeakMap","WeakSet","Set","setValue","value_1","value_1_1","element","add","Date","_a","keys","_b","empty","wrap","action","defineProperty","ConnectBase","connect","split","JSON","stringify","ngOnDestroy","formSubscription","unsubscribe","stateSubscription","ngAfterContentInit","Promise","resolve","then","resetState","pipe","debounceTime","values","publish","descendants","formElement","pairs","FormArray","controls","c","FormGroup","NgControl","FormControl","control","name","filter","_parent","Input","ReactiveConnectDirective","Directive","args","selector","ConnectDirective","NgForm","declarations","NgModule","exports","ConnectArrayTemplate","$implicit","item","ConnectArrayDirective","rawValidators","rawAsyncValidators","connection","templateRef","viewContainerRef","registerInternals","array","collection","ngOnInit","formDirective","addControl","controlPath","Validators","compose","composeAsync","updateValueAndValidity","removeControl","iterable","iterable_1","iterable_1_1","viewRef","embeddedViewRef","createEmbeddedView","patchDescendantControls","insert","transform","context","remove","registerControl","registerOnChange","defineProperties","_rawValidators","_rawAsyncValidators","_view","map","NgModelGroup","_checkParentType","reference","emptyControl","setParent","toJS","iterate","removeAt","iterable_2","iterable_2_1","associate","group","toString","providers","provide","ControlContainer","useExisting","forwardRef","decorators","Optional","Host","SkipSelf","Self","Inject","NG_VALIDATORS","NG_ASYNC_VALIDATORS","TemplateRef","ViewContainerRef","formStoreFactory","ngRedux","imports","FormsModule","ReactiveFormsModule","NgReduxFormConnectModule","NgReduxFormConnectArrayModule","useFactory","deps","reducers","_i","reduce","st","reducer","initialState","abstractStore","useValue"],"mappings":"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","sourcesContent":["import { AnyAction, Reducer } from 'redux';\n\nexport const composeReducers = <State>(\n  ...reducers: Reducer<State, AnyAction>[]\n): Reducer<State, AnyAction> => (s: any, action: AnyAction) =>\n  reducers.reduce((st, reducer) => reducer(st, action), s);\n","import { Injectable } from '@angular/core';\n\nimport { NgForm } from '@angular/forms';\n\nimport { NgRedux } from '@angular-redux/store';\n\nimport { Action, Unsubscribe } from 'redux';\n\nexport interface AbstractStore<RootState> {\n  /// Dispatch an action\n  dispatch(action: Action & { payload: any }): void;\n\n  /// Retrieve the current application state\n  getState(): RootState;\n\n  /// Subscribe to changes in the store\n  subscribe(fn: (state: RootState) => void): Unsubscribe;\n}\n\nexport const FORM_CHANGED = '@@angular-redux/form/FORM_CHANGED';\n\n@Injectable()\nexport class FormStore {\n  /// NOTE(cbond): The declaration of store is misleading. This class is\n  /// actually capable of taking a plain Redux store or an NgRedux instance.\n  /// But in order to make the ng dependency injector work properly, we\n  /// declare it as an NgRedux type, since the @angular-redux/store use case involves\n  /// calling the constructor of this class manually (from configure.ts),\n  /// where a plain store can be cast to an NgRedux. (For our purposes, they\n  /// have almost identical shapes.)\n  constructor(private store: NgRedux<any>) {}\n\n  getState() {\n    return this.store.getState();\n  }\n\n  subscribe(fn: (state: any) => void): Unsubscribe {\n    return this.store.subscribe(() => fn(this.getState()));\n  }\n\n  valueChanged<T>(path: string[], form: NgForm, value: T) {\n    this.store.dispatch({\n      type: FORM_CHANGED,\n      payload: {\n        path,\n        form,\n        valid: form.valid === true,\n        value,\n      },\n    });\n  }\n}\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","export class FormException extends Error {\n  constructor(msg: string) {\n    super(msg);\n  }\n}\n","import { Iterable, Map as ImmutableMap } from 'immutable';\n\nimport { FormException } from './form-exception';\n\nexport interface Operations<T> {\n  /// Shallow clone the object\n  clone(): T;\n\n  /// Clone and merge\n  merge(key: number | string | null, value: T): any;\n\n  /// Clone the object and update a specific key inside of it\n  update(key: number | string | null, value: T): any;\n}\n\nexport type TraverseCallback = (\n  parent: any,\n  key: number | string,\n  remainingPath: string[],\n  value?: any,\n) => any;\n\nexport abstract class State {\n  static traverse<StateType>(\n    state: StateType,\n    path: string[],\n    fn?: TraverseCallback,\n  ) {\n    let deepValue = state;\n\n    for (const k of path) {\n      const parent = deepValue;\n\n      if (Iterable.isIterable(deepValue)) {\n        const m = (deepValue as any) as ImmutableMap<string, any>;\n        if (typeof m.get === 'function') {\n          deepValue = m.get(k);\n        } else {\n          throw new FormException(\n            `Cannot retrieve value from immutable nonassociative container: ${k}`,\n          );\n        }\n      } else if (deepValue instanceof Map) {\n        deepValue = ((deepValue as any) as Map<string, any>).get(k);\n      } else {\n        deepValue = (deepValue as any)[k];\n      }\n\n      if (typeof fn === 'function') {\n        const transformed = fn(\n          parent,\n          k,\n          path.slice(path.indexOf(k) + 1),\n          deepValue,\n        );\n\n        deepValue = transformed[k];\n\n        Object.assign(parent, transformed);\n      }\n\n      // If we were not able to find this state inside of our root state\n      // structure, then we return undefined -- not null -- to indicate that\n      // state. But this could be a perfectly normal use-case so we don't\n      // want to throw an exception or anything along those lines.\n      if (deepValue === undefined) {\n        return undefined;\n      }\n    }\n\n    return deepValue;\n  }\n\n  static get<StateType>(state: StateType, path: string[]): any {\n    return State.traverse(state, path);\n  }\n\n  static assign<StateType>(state: StateType, path: string[], value?: any) {\n    const operations = State.inspect(state);\n\n    if (path.length === 0) {\n      return operations.update(null, value);\n    }\n\n    const root = operations.clone();\n\n    // We want to shallow clone the object, and then trace a path to the place\n    // we want to update, cloning each object we traversed on our way and then\n    // finally updating the value on the last parent to be @value. This seems\n    // to offer the best performance: we can shallow clone everything that has\n    // not been modified, and {deep clone + update} the path down to the value\n    // that we wish to update.\n    State.traverse(\n      root,\n      path,\n      (parent, key: number | string, remainingPath: string[], innerValue?) => {\n        const parentOperations = State.inspect(parent);\n\n        if (innerValue) {\n          const innerOperations = State.inspect(innerValue);\n\n          return parentOperations.update(\n            key,\n            remainingPath.length > 0\n              ? innerOperations.clone()\n              : innerOperations.merge(null, value),\n          );\n        } else {\n          const getProbableType = (stateKey: string | number) => {\n            // NOTE(cbond): If your code gets here, you might not be using the library\n            /// correctly. If you are assigning into a path in your state, try to\n            /// ensure that there is a path to traverse, even if everything is just\n            /// empty objects and arrays. If we have to guess the type of the containers\n            /// and then create them ourselves, we may not get the types right. Use\n            /// the Redux `initial state' construct to resolve this issue if you like.\n            return typeof stateKey === 'number'\n              ? new Array()\n              : Array.isArray(stateKey)\n                ? ImmutableMap()\n                : new Object();\n          };\n\n          return parentOperations.update(\n            key,\n            remainingPath.length > 0\n              ? getProbableType(remainingPath[0])\n              : value,\n          );\n        }\n      },\n    );\n\n    return root;\n  }\n\n  static inspect<K>(object: K): Operations<K> {\n    const metaOperations = (\n      // TODO: Write proper type declarations for following Function types\n      update: Function,\n      merge: Function,\n      clone?: Function,\n    ) => {\n      const operations = {\n        /// Clone the object (shallow)\n        clone:\n          typeof clone === 'function'\n            ? () => clone(object as any) as any\n            : () => object,\n\n        /// Update a specific key inside of the container object\n        update: (key: string, value: K) =>\n          update(operations.clone(), key, value),\n\n        /// Merge existing values with new values\n        merge: (key: string, value: K) => {\n          const cloned = operations.clone();\n          return merge(cloned, key, value, (v: any) => update(cloned, key, v));\n        },\n      };\n\n      return operations;\n    };\n\n    if (Iterable.isIterable(object)) {\n      return metaOperations(\n        // Replace\n        (parent: any, key: number | string, value: K) => {\n          if (key != null) {\n            return parent.set(key, value);\n          } else {\n            return value;\n          }\n        },\n        // Merge\n        (parent: any, key: number | string | string[], value: K) => {\n          if (key) {\n            return parent.mergeDeepIn(Array.isArray(key) ? key : [key], value);\n          } else {\n            if (ImmutableMap.isMap(value)) {\n              return parent.mergeDeep(value);\n            } else {\n              return parent.concat(value);\n            }\n          }\n        },\n      );\n    } else if (Array.isArray(object)) {\n      return metaOperations(\n        // Replace array contents\n        (parent: any, key: number, value: K) => {\n          if (key != null) {\n            parent[key] = value;\n          } else {\n            parent.splice.apply(\n              parent,\n              [0, parent.length].concat(Array.isArray(value) ? value : [value]),\n            );\n          }\n        },\n\n        // Merge\n        (parent: any, _: any, value: K, setter: (v: K) => K) => {\n          setter(parent.concat(value));\n          return parent;\n        },\n\n        // Clone\n        () => Array.prototype.slice.call(object, 0),\n      );\n    } else if (object instanceof Map) {\n      return metaOperations(\n        // Update map key\n        (parent: any, key: number | string, value: K) => {\n          if (key != null) {\n            return parent.set(key, value);\n          } else {\n            const m = new Map(value as any);\n            parent.clear();\n            m.forEach((mapValue, index) => parent.set(index, mapValue));\n            return parent;\n          }\n        },\n\n        // Merge\n        (parent: Map<string, any>, _: any, value: K) => {\n          const m = new Map<string, any>(value as any);\n          m.forEach((mapValue, key) => parent.set(key, mapValue));\n          return parent;\n        },\n\n        // Clone\n        () =>\n          object instanceof WeakMap\n            ? new WeakMap<object, any>(object as any)\n            : new Map<string, any>(object as any),\n      );\n    } else if (object instanceof WeakSet || object instanceof Set) {\n      return metaOperations(\n        // Update element at index in set\n        (parent: any, key: number, value: K) => {\n          if (key != null) {\n            return parent.set(key, value);\n          } else {\n            const s = new Set(value as any);\n            s.forEach((setValue, index) => parent.set(index, setValue));\n            s.clear();\n            return parent;\n          }\n        },\n\n        // Merge\n        (parent: Set<any>, _: any, value: any) => {\n          for (const element of value) {\n            parent.add(element);\n          }\n          return parent;\n        },\n\n        // Clone\n        () =>\n          object instanceof WeakSet\n            ? new WeakSet<any>(object as any)\n            : new Set<any>(object as any),\n      );\n    } else if (object instanceof Date) {\n      throw new FormException(\n        'Cannot understand why a Date object appears in the mutation path!',\n      );\n    } else {\n      switch (typeof object) {\n        case 'boolean':\n        case 'function':\n        case 'number':\n        case 'string':\n        case 'symbol':\n        case 'undefined':\n          break;\n        case 'object':\n          if (object == null) {\n            break;\n          }\n          return metaOperations(\n            (parent: any, key: any, value: K) => {\n              if (key != null) {\n                return { ...parent, [key]: value };\n              }\n              return { ...parent, ...(value as any) };\n            },\n            (parent: any, _: any, value: K) => {\n              for (const k of Object.keys(value)) {\n                parent[k] = (value as any)[k];\n              }\n              return parent;\n            },\n            () => ({ ...(object as any) }),\n          );\n        default:\n          break;\n      }\n    }\n\n    throw new Error(\n      `An object of type ${typeof object} has appeared in the mutation path! Every element ` +\n        'in the mutation path should be an array, an associative container, or a set',\n    );\n  }\n\n  static empty(value: any): boolean {\n    return (\n      value == null ||\n      (value.length === 0 ||\n        (typeof value.length === 'undefined' &&\n          Object.keys(value).length === 0))\n    );\n  }\n}\n","import { Action, Store } from 'redux';\n\nimport { AbstractStore, FormStore } from './form-store';\n\n/// Use this function in your providers list if you are not using @angular-redux/core.\n/// This will allow you to provide a preexisting store that you have already\n/// configured, rather than letting @angular-redux/core create one for you.\nexport const provideReduxForms = <T>(store: Store<T> | any) => {\n  const abstractStore = wrap(store);\n\n  return [\n    { provide: FormStore, useValue: new FormStore(abstractStore as any) },\n  ];\n};\n\nconst wrap = <T>(store: Store<T> | any): AbstractStore<T> => {\n  const dispatch = (action: Action) => store.dispatch(action);\n\n  const getState = () => store.getState() as T;\n\n  const subscribe = (fn: (state: T) => void) =>\n    store.subscribe(() => fn(store.getState()));\n\n  return { dispatch, getState, subscribe };\n};\n","import { AfterContentInit, Input, OnDestroy } from '@angular/core';\n\nimport {\n  AbstractControl,\n  FormArray,\n  FormControl,\n  FormGroup,\n  NgControl,\n} from '@angular/forms';\n\nimport { Subscription } from 'rxjs';\n\nimport { Unsubscribe } from 'redux';\n\nimport { debounceTime } from 'rxjs/operators';\n\nimport { FormStore } from '../form-store';\nimport { State } from '../state';\n\nexport interface ControlPair {\n  path: string[];\n  control: AbstractControl;\n}\n\nexport class ConnectBase implements OnDestroy, AfterContentInit {\n  get path(): string[] {\n    const path =\n      typeof this.connect === 'function' ? this.connect() : this.connect;\n\n    switch (typeof path) {\n      case 'object':\n        if (State.empty(path)) {\n          return [];\n        }\n        if (Array.isArray(path)) {\n          return path as string[];\n        }\n      case 'string':\n        return (path as string).split(/\\./g);\n      default:\n        // fallthrough above (no break)\n        throw new Error(\n          `Cannot determine path to object: ${JSON.stringify(path)}`,\n        );\n    }\n  }\n  @Input() connect?: () => (string | number) | (string | number)[];\n  protected store?: FormStore;\n  protected form: any;\n  private stateSubscription?: Unsubscribe;\n\n  private formSubscription?: Subscription;\n\n  ngOnDestroy() {\n    if (this.formSubscription) {\n      this.formSubscription.unsubscribe();\n    }\n\n    if (typeof this.stateSubscription === 'function') {\n      this.stateSubscription(); // unsubscribe\n    }\n  }\n\n  ngAfterContentInit() {\n    Promise.resolve().then(() => {\n      this.resetState();\n\n      if (this.store) {\n        this.stateSubscription = this.store.subscribe(() => this.resetState());\n      }\n\n      Promise.resolve().then(() => {\n        this.formSubscription = (this.form.valueChanges as any)\n          .pipe(debounceTime(0))\n          .subscribe((values: any) => this.publish(values));\n      });\n    });\n  }\n\n  private descendants(path: string[], formElement: any): ControlPair[] {\n    const pairs = new Array<ControlPair>();\n\n    if (formElement instanceof FormArray) {\n      formElement.controls.forEach((c, index) => {\n        for (const d of this.descendants((path as any).concat([index]), c)) {\n          pairs.push(d);\n        }\n      });\n    } else if (formElement instanceof FormGroup) {\n      for (const k of Object.keys(formElement.controls)) {\n        pairs.push({\n          path: path.concat([k]),\n          control: formElement.controls[k],\n        });\n      }\n    } else if (\n      formElement instanceof NgControl ||\n      formElement instanceof FormControl\n    ) {\n      return [{ path, control: formElement as any }];\n    } else {\n      throw new Error(\n        `Unknown type of form element: ${formElement.constructor.name}`,\n      );\n    }\n\n    return pairs.filter(p => {\n      const parent = (p.control as any)._parent;\n      return parent === this.form.control || parent === this.form;\n    });\n  }\n\n  private resetState() {\n    const formElement =\n      this.form.control === undefined ? this.form : this.form.control;\n\n    const children = this.descendants([], formElement);\n\n    children.forEach(c => {\n      const { path, control } = c;\n\n      const value = State.get(this.getState(), this.path.concat(path));\n\n      if (control.value !== value) {\n        control.setValue(value);\n      }\n    });\n  }\n\n  private publish(value: any) {\n    if (this.store) {\n      this.store.valueChanged(this.path, this.form, value);\n    }\n  }\n\n  private getState() {\n    if (this.store) {\n      return this.store.getState();\n    }\n  }\n}\n","import { Directive, Input } from '@angular/core';\n\nimport { FormStore } from '../form-store';\n\nimport { ConnectBase } from './connect-base';\n\n// For reactive forms (without implicit NgForm)\n@Directive({ selector: 'form[connect][formGroup]' })\nexport class ReactiveConnectDirective extends ConnectBase {\n  @Input() formGroup: any;\n\n  constructor(protected store: FormStore) {\n    super();\n  }\n}\n","import { Directive } from '@angular/core';\n\nimport { NgForm } from '@angular/forms';\n\nimport { FormStore } from '../form-store';\nimport { ConnectBase } from './connect-base';\n\n// For template forms (with implicit NgForm)\n@Directive({ selector: 'form[connect]:not([formGroup])' })\nexport class ConnectDirective extends ConnectBase {\n  constructor(protected store: FormStore, protected form: NgForm) {\n    super();\n  }\n}\n","import { NgModule } from '@angular/core';\n\nimport { ConnectDirective } from './connect';\nimport { ReactiveConnectDirective } from './connect-reactive';\n\nconst declarations = [ConnectDirective, ReactiveConnectDirective];\n\n@NgModule({\n  declarations: [...declarations],\n  exports: [...declarations],\n})\nexport class NgReduxFormConnectModule {}\n","export class ConnectArrayTemplate {\n  constructor(public $implicit: any, public index: number, public item: any) {}\n}\n","import {\n  Directive,\n  EmbeddedViewRef,\n  forwardRef,\n  Host,\n  Inject,\n  Input,\n  OnDestroy,\n  OnInit,\n  Optional,\n  Self,\n  SkipSelf,\n  TemplateRef,\n  ViewContainerRef,\n} from '@angular/core';\nimport {\n  AbstractControl,\n  AsyncValidatorFn,\n  ControlContainer,\n  FormArray,\n  FormControl,\n  FormGroup,\n  FormGroupDirective,\n  NG_ASYNC_VALIDATORS,\n  NG_VALIDATORS,\n  NgModelGroup,\n  ValidatorFn,\n  Validators,\n} from '@angular/forms';\nimport { Unsubscribe } from 'redux';\n\nimport { ConnectBase } from '../connect';\nimport { FormStore } from '../form-store';\nimport { controlPath } from '../shims';\nimport { State } from '../state';\nimport { ConnectArrayTemplate } from './connect-array-template';\n\n@Directive({\n  selector: '[connectArray]',\n  providers: [\n    {\n      provide: ControlContainer,\n      useExisting: forwardRef(() => ConnectArrayDirective),\n    },\n  ],\n})\nexport class ConnectArrayDirective extends ControlContainer\n  implements OnInit, OnDestroy {\n  private stateSubscription: Unsubscribe;\n\n  private array = new FormArray([]);\n\n  private key?: string;\n\n  constructor(\n    @Optional()\n    @Host()\n    @SkipSelf()\n    private parent: ControlContainer,\n    @Optional()\n    @Self()\n    @Inject(NG_VALIDATORS)\n    private rawValidators: any[],\n    @Optional()\n    @Self()\n    @Inject(NG_ASYNC_VALIDATORS)\n    private rawAsyncValidators: any[],\n    private connection: ConnectBase,\n    private templateRef: TemplateRef<any>,\n    private viewContainerRef: ViewContainerRef,\n    private store: FormStore,\n  ) {\n    super();\n\n    this.stateSubscription = this.store.subscribe(state =>\n      this.resetState(state),\n    );\n\n    this.registerInternals(this.array);\n  }\n\n  @Input()\n  set connectArrayOf(collection: any) {\n    this.key = collection;\n\n    this.resetState(this.store.getState());\n  }\n\n  ngOnInit() {\n    this.formDirective.addControl(this as any);\n  }\n\n  get name(): string {\n    return this.key || '';\n  }\n\n  get control(): FormArray {\n    return this.array;\n  }\n\n  get formDirective(): FormGroupDirective {\n    return this.parent.formDirective as FormGroupDirective;\n  }\n\n  get path(): string[] {\n    return this.key ? controlPath(this.key, this.parent) : [];\n  }\n\n  get validator(): ValidatorFn | null {\n    return Validators.compose(this.rawValidators);\n  }\n\n  get asyncValidator(): AsyncValidatorFn | null {\n    return Validators.composeAsync(this.rawAsyncValidators);\n  }\n\n  updateValueAndValidity() {\n    // stub?\n  }\n\n  ngOnDestroy() {\n    this.viewContainerRef.clear();\n\n    if (this.key) {\n      this.formDirective.form.removeControl(this.key);\n    }\n\n    this.stateSubscription();\n  }\n\n  private resetState(state: any) {\n    if (this.key == null || this.key.length === 0) {\n      return; // no state to retreive if no key is set\n    }\n\n    const iterable = State.get(state, this.connection.path.concat(this.path));\n\n    let index = 0;\n\n    for (const value of iterable) {\n      const viewRef =\n        this.viewContainerRef.length > index\n          ? (this.viewContainerRef.get(index) as EmbeddedViewRef<\n              ConnectArrayTemplate\n            >)\n          : null;\n\n      if (viewRef == null) {\n        const embeddedViewRef = this.viewContainerRef.createEmbeddedView<\n          ConnectArrayTemplate\n        >(\n          this.templateRef,\n          new ConnectArrayTemplate(index, index, value),\n          index,\n        );\n\n        this.patchDescendantControls(embeddedViewRef);\n\n        this.array.insert(\n          index,\n          this.transform(this.array, embeddedViewRef.context.item),\n        );\n      } else {\n        Object.assign(\n          viewRef.context,\n          new ConnectArrayTemplate(index, index, value),\n        );\n      }\n\n      ++index;\n    }\n\n    while (this.viewContainerRef.length > index) {\n      this.viewContainerRef.remove(this.viewContainerRef.length - 1);\n    }\n  }\n\n  private registerInternals(array: any) {\n    array.registerControl = () => undefined;\n    array.registerOnChange = () => undefined;\n\n    Object.defineProperties(this, {\n      _rawValidators: {\n        value: this.rawValidators || [],\n      },\n      _rawAsyncValidators: {\n        value: this.rawAsyncValidators || [],\n      },\n    });\n  }\n\n  private patchDescendantControls(viewRef: any) {\n    const groups = Object.keys(viewRef._view)\n      .map(k => viewRef._view[k])\n      .filter(c => c instanceof NgModelGroup);\n\n    groups.forEach(c => {\n      Object.defineProperties(c, {\n        _parent: {\n          value: this,\n        },\n        _checkParentType: {\n          value: () => undefined,\n        },\n      });\n    });\n  }\n\n  private transform(\n    parent: FormGroup | FormArray,\n    reference: any,\n  ): AbstractControl {\n    const emptyControl = () => {\n      const control = new FormControl(null);\n      control.setParent(parent);\n      return control;\n    };\n\n    if (reference == null) {\n      return emptyControl();\n    }\n\n    if (typeof reference.toJS === 'function') {\n      reference = reference.toJS();\n    }\n\n    switch (typeof reference) {\n      case 'string':\n      case 'number':\n      case 'boolean':\n        return emptyControl();\n    }\n\n    const iterate = (iterable: any): FormArray => {\n      const array = new FormArray([]);\n\n      this.registerInternals(array);\n\n      for (let i = array.length; i > 0; i--) {\n        array.removeAt(i);\n      }\n\n      for (const value of iterable) {\n        const transformed = this.transform(array, value);\n        if (transformed) {\n          array.push(transformed);\n        }\n      }\n\n      return array;\n    };\n\n    const associate = (value: any): FormGroup => {\n      const group = new FormGroup({});\n      group.setParent(parent);\n\n      for (const key of Object.keys(value)) {\n        const transformed = this.transform(group, value[key]);\n        if (transformed) {\n          group.addControl(key, transformed);\n        }\n      }\n\n      return group;\n    };\n\n    if (Array.isArray(reference)) {\n      return iterate(reference as any[]);\n    } else if (reference instanceof Set) {\n      return iterate(reference as Set<any>);\n    } else if (reference instanceof Map) {\n      return associate(reference as Map<string, any>);\n    } else if (reference instanceof Object) {\n      return associate(reference);\n    } else {\n      throw new Error(\n        `Cannot convert object of type ${typeof reference} / ${reference.toString()} to form element`,\n      );\n    }\n  }\n}\n","import {\n  CheckboxControlValueAccessor,\n  ControlContainer,\n  ControlValueAccessor,\n  RadioControlValueAccessor,\n  SelectControlValueAccessor,\n  SelectMultipleControlValueAccessor,\n} from '@angular/forms';\n\nexport function controlPath(name: string, parent: ControlContainer): string[] {\n  return [...(parent.path || []), name];\n}\n\nconst BUILTIN_ACCESSORS = [\n  CheckboxControlValueAccessor,\n  SelectControlValueAccessor,\n  SelectMultipleControlValueAccessor,\n  RadioControlValueAccessor,\n];\n\nexport function isBuiltInAccessor(\n  valueAccessor: ControlValueAccessor,\n): boolean {\n  return BUILTIN_ACCESSORS.some(a => valueAccessor.constructor === a);\n}\n","import { NgModule } from '@angular/core';\n\nimport { ConnectArrayDirective } from './connect-array';\n\nconst declarations = [ConnectArrayDirective];\n\n@NgModule({\n  declarations: [...declarations],\n  exports: [...declarations],\n})\nexport class NgReduxFormConnectArrayModule {}\n","import { NgRedux } from '@angular-redux/store';\nimport { NgModule } from '@angular/core';\nimport { FormsModule, ReactiveFormsModule } from '@angular/forms';\n\nimport { NgReduxFormConnectModule } from './connect';\nimport { NgReduxFormConnectArrayModule } from './connect-array';\nimport { FormStore } from './form-store';\n\nexport function formStoreFactory(ngRedux: NgRedux<any>) {\n  return new FormStore(ngRedux);\n}\n\n@NgModule({\n  imports: [\n    FormsModule,\n    ReactiveFormsModule,\n    NgReduxFormConnectModule,\n    NgReduxFormConnectArrayModule,\n  ],\n  exports: [NgReduxFormConnectModule, NgReduxFormConnectArrayModule],\n  providers: [\n    {\n      provide: FormStore,\n      useFactory: formStoreFactory,\n      deps: [NgRedux],\n    },\n  ],\n})\nexport class NgReduxFormModule {}\n","import { Iterable } from 'immutable';\n\nimport { Action } from 'redux';\n\nimport { FORM_CHANGED } from './form-store';\n\nimport { State } from './state';\n\nexport const defaultFormReducer = <RootState>(\n  initialState?: RootState | Iterable.Keyed<string, any>,\n) => {\n  const reducer = (\n    state: RootState | Iterable.Keyed<string, any> | undefined = initialState,\n    action: Action & { payload?: any },\n  ) => {\n    switch (action.type) {\n      case FORM_CHANGED:\n        return State.assign(state, action.payload.path, action.payload.value);\n      default:\n        return state;\n    }\n  };\n\n  return reducer;\n};\n"]}